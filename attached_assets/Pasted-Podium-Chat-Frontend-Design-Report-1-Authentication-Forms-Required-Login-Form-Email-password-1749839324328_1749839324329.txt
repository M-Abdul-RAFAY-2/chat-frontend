Podium Chat Frontend Design Report
1. Authentication
Forms Required:
Login Form: Email & password fields, submit button, error display.
Register Form: Name, email, password fields, submit button, error display, success message.
API Endpoints:
POST /api/v1/auth/login (returns JWT token)
POST /api/v1/auth/register (creates user)
Behavior:
On successful login, store JWT in localStorage and redirect to chat.
On registration, show success and redirect to login.
Handle and display backend validation errors.
2. Main Chat Interface
Layout:
Sidebar (Conversations List): Shows all conversations for the logged-in user/org.
Main Panel (Chat View): Shows messages for the selected conversation.
Responsive Design: Sidebar collapses on mobile; chat view takes full width.
API Endpoints:
GET /api/v1/conversations (list conversations)
GET /api/v1/messages/conversation/:conversationId (fetch messages for a conversation)
POST /api/v1/messages (send a new message)
Behavior:
Fetch and display conversations on load.
When a conversation is selected, fetch and display its messages.
Allow sending new messages (text input + send button).
Show real-time updates using Socket.IO (new messages, typing indicators, assignment notifications).
Mark unread/read status visually.
3. Conversation Management
Features:
Start New Conversation: (optional, if supported by backend)
Assign/Unassign Conversation: Show assignment status, allow assignment if user is admin/agent.
Conversation Filters: Filter by status (open, closed, etc.), search by customer name.
API Endpoints:
POST /api/v1/conversations (create new conversation)
PATCH /api/v1/conversations/:id (update assignment/status, if supported)
Behavior:
Update UI in real-time when assignment changes (via Socket.IO).
Show conversation status and assignee.
4. Customer Management
Features:
Customer List: (optional, for admin/agent roles)
Customer Details: Show customer info in chat sidebar or modal.
API Endpoints:
GET /api/v1/customers (list customers)
GET /api/v1/customers/:id (customer details)
Behavior:
Display customer info when viewing a conversation.
5. Templates, Campaigns, Rules, Integrations (Admin Features)
Features:
Templates: List, create, edit message templates.
Campaigns: List, create, schedule campaigns.
Rules: List, create, edit automation rules.
Integrations: List, configure integrations (e.g., SMS, WhatsApp).
API Endpoints:
GET/POST/PATCH /api/v1/templates
GET/POST/PATCH /api/v1/campaigns
GET/POST/PATCH /api/v1/rules
GET/POST/PATCH /api/v1/integrations
Behavior:
Admin-only access, forms for CRUD operations, show feedback on success/error.
6. Real-Time Features (Socket.IO)
Events to Handle:
New message received (message:new)
Typing indicators (typing:start, typing:stop)
Conversation assignment (conversation:assigned)
Behavior:
Join relevant Socket.IO rooms after login (user, org, conversation).
Update UI instantly on relevant events.
7. General UI/UX
Responsiveness:
Use Tailwind CSS for mobile-first, responsive layouts.
Sidebar collapses on small screens; chat view is full width.
Forms and buttons are touch-friendly.
Dynamic Behavior:
Loading spinners, error messages, and empty states.
Optimistic UI updates for sending messages.
Smooth transitions and modals for details/settings.
8. Security & Session Management
Store JWT securely (localStorage or httpOnly cookie).
Attach JWT as Authorization header for all API requests.
Redirect to login if token is missing or expired.
9. Accessibility
Use semantic HTML and ARIA attributes.
Ensure keyboard navigation and screen reader support.
10. Optional Enhancements
Notifications: Browser or in-app notifications for new messages.
User Profile: Allow users to view/edit their profile.
Analytics Dashboard: For admins, show stats from backend.
Summary:
The frontend should provide a seamless, responsive, and dynamic chat experience, leveraging your backendâ€™s REST and real-time APIs. Each major feature (auth, chat, management, admin) should have its own forms and views, hitting the corresponding backend endpoints, and updating the UI in real time using Socket.IO.

Let me know if you want a detailed UI wireframe or user flow next!